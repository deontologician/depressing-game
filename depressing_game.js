define("depressing_data", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERY_DEPRESSING_DATA = {
        inflation: 0.03,
        // http://cost-of-living.careertrends.com/l/615/The-United-States
        cost_of_living: 28458,
        death_rates: {
            18: { male: 0.000735, female: 0.0002978 },
            19: { male: 0.000869, female: 0.0003340 },
            20: { male: 0.001011, female: 0.0003732 },
            21: { male: 0.001145, female: 0.0004125 },
            22: { male: 0.001246, female: 0.0004467 },
            23: { male: 0.001301, female: 0.0004720 },
            24: { male: 0.001321, female: 0.0004932 },
            25: { male: 0.001330, female: 0.0005135 },
            26: { male: 0.001345, female: 0.0005378 },
            27: { male: 0.001363, female: 0.0005631 },
            28: { male: 0.001391, female: 0.0005934 },
            29: { male: 0.001427, female: 0.0006277 },
            30: { male: 0.001467, female: 0.0006641 },
            31: { male: 0.001505, female: 0.0007054 },
            32: { male: 0.001541, female: 0.0007488 },
            33: { male: 0.001573, female: 0.0007941 },
            34: { male: 0.001606, female: 0.0008455 },
            35: { male: 0.001648, female: 0.0009039 },
            36: { male: 0.001704, female: 0.0009683 },
            37: { male: 0.001774, female: 0.0010388 },
            38: { male: 0.001861, female: 0.0011133 },
            39: { male: 0.001967, female: 0.0011967 },
            40: { male: 0.002092, female: 0.0012873 },
            41: { male: 0.002240, female: 0.0013938 },
            42: { male: 0.002418, female: 0.0015174 },
            43: { male: 0.002629, female: 0.0016620 },
            44: { male: 0.002873, female: 0.0018276 },
            45: { male: 0.003146, female: 0.0020053 },
            46: { male: 0.003447, female: 0.0021981 },
            47: { male: 0.003787, female: 0.0024129 },
            48: { male: 0.004167, female: 0.0026487 },
            49: { male: 0.004586, female: 0.0029046 },
            50: { male: 0.005038, female: 0.0031826 },
            51: { male: 0.005520, female: 0.0034737 },
            52: { male: 0.006036, female: 0.0037678 },
            53: { male: 0.006587, female: 0.0040589 },
            54: { male: 0.007170, female: 0.0043522 },
            55: { male: 0.007801, female: 0.0046814 },
            56: { male: 0.008466, female: 0.0050408 },
            57: { male: 0.009133, female: 0.0054001 },
            58: { male: 0.009792, female: 0.0057566 },
            59: { male: 0.010462, female: 0.0061281 },
            60: { male: 0.011197, female: 0.0065456 },
            61: { male: 0.012009, female: 0.0070342 },
            62: { male: 0.012867, female: 0.0076078 },
            63: { male: 0.013772, female: 0.0082815 },
            64: { male: 0.014749, female: 0.0090573 },
            65: { male: 0.015852, female: 0.0099532 },
            66: { male: 0.017097, female: 0.0109502 },
            67: { male: 0.018463, female: 0.0120103 },
            68: { male: 0.019959, female: 0.0131245 },
            69: { male: 0.021616, female: 0.0143308 },
            70: { male: 0.023528, female: 0.0157283 },
            71: { male: 0.025693, female: 0.0173388 },
            72: { male: 0.028041, female: 0.0191085 },
            73: { male: 0.030567, female: 0.0210413 },
            74: { male: 0.033347, female: 0.0231913 },
            75: { male: 0.036572, female: 0.0257133 },
            76: { male: 0.040276, female: 0.0286096 },
            77: { male: 0.044348, female: 0.0317600 },
            78: { male: 0.048797, female: 0.0351576 },
            79: { male: 0.053739, female: 0.0389204 },
            80: { male: 0.059403, female: 0.043289 },
            81: { male: 0.065873, female: 0.048356 },
            82: { male: 0.073082, female: 0.054041 },
            83: { male: 0.081070, female: 0.060384 },
            84: { male: 0.089947, female: 0.067498 },
            85: { male: 0.099842, female: 0.075516 },
            86: { male: 0.110863, female: 0.084556 },
            87: { male: 0.123088, female: 0.094703 },
            88: { male: 0.136563, female: 0.106014 },
            89: { male: 0.151299, female: 0.118513 },
            90: { male: 0.167291, female: 0.132206 },
            91: { male: 0.184520, female: 0.147092 },
            92: { male: 0.202954, female: 0.163154 },
            93: { male: 0.222555, female: 0.180371 },
            94: { male: 0.243272, female: 0.198714 },
            95: { male: 0.263821, female: 0.217264 },
            96: { male: 0.283833, female: 0.235735 },
            97: { male: 0.302916, female: 0.253810 },
            98: { male: 0.320672, female: 0.271155 },
            99: { male: 0.336706, female: 0.287424 },
            100: { male: 0.353541, female: 0.304670 },
            101: { male: 0.371218, female: 0.322950 },
            102: { male: 0.389779, female: 0.342327 },
            103: { male: 0.409268, female: 0.362867 },
            104: { male: 0.429732, female: 0.384639 },
            105: { male: 0.451218, female: 0.407717 },
            106: { male: 0.473779, female: 0.432180 },
            107: { male: 0.497468, female: 0.458111 },
            108: { male: 0.522341, female: 0.485597 },
            109: { male: 0.548458, female: 0.514733 },
            110: { male: 0.575881, female: 0.545617 },
            111: { male: 0.604675, female: 0.578354 },
            112: { male: 0.634909, female: 0.613055 },
            113: { male: 0.666655, female: 0.649839 },
            114: { male: 0.699987, female: 0.688829 },
            115: { male: 0.734987, female: 0.730159 },
            116: { male: 0.771736, female: 0.771736 },
            117: { male: 0.810323, female: 0.810323 },
            118: { male: 0.850839, female: 0.850839 },
            119: { male: 0.893381, female: 0.893381 },
        },
        // Reasons for getting fired
        // "You were fired because ..."
        reasons_for_termination: [
            "you let the llamas out, again.",
            "you slept with boss's spouse.",
            "you punched HR director.",
            "you stole money from the cash register.",
            "you yelled at customer.",
            "you screwed up the big account, lost millions for the company.",
            "you were sleeping on the job.",
            "you were downsized.",
            "you lost the company car.",
            "you were bad at your job.",
            "you stole the stapler from your job.",
            "you took too much time off from work.",
            "you yelled at your boss.",
            "you were caught with booze at work.",
            "you don't fit in with company culture.",
            "your paranoia got you fired. You thought this would happen.",
            "you were caught doodling at work.",
            "your poor file management.",
            "you were stress eating from the vending machine.",
            "you stole money from the vault.",
            "you stole someone else's lunch from the fridge.",
            "you were unable to understand elevators.",
            "you were not a team player.",
            "you were reading too much Reddit.",
            "you were operating a ponzi scheme from the office.",
            "you were the office gossip.",
            "you were the source of office gossip.",
            "you were spending too much time on Facebook.",
            "you caused an 'incident'.",
            "you were embezzling.",
        ],
    };
});
// Comment that is displayed in the API documentation for the maquette module:
/**
 * Welcome to the API documentation of the **maquette** library.
 *
 * [[http://maquettejs.org/|To the maquette homepage]]
 */
define("third-party/maquette", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const NAMESPACE_W3 = 'http://www.w3.org/';
    const NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';
    const NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';
    // Utilities
    let emptyArray = [];
    let extend = (base, overrides) => {
        let result = {};
        Object.keys(base).forEach(function (key) {
            result[key] = base[key];
        });
        if (overrides) {
            Object.keys(overrides).forEach((key) => {
                result[key] = overrides[key];
            });
        }
        return result;
    };
    // Hyperscript helper functions
    let same = (vnode1, vnode2) => {
        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {
            return false;
        }
        if (vnode1.properties && vnode2.properties) {
            if (vnode1.properties.key !== vnode2.properties.key) {
                return false;
            }
            return vnode1.properties.bind === vnode2.properties.bind;
        }
        return !vnode1.properties && !vnode2.properties;
    };
    let toTextVNode = (data) => {
        return {
            vnodeSelector: '',
            properties: undefined,
            children: undefined,
            text: data.toString(),
            domNode: null
        };
    };
    let appendChildren = function (parentSelector, insertions, main) {
        for (let i = 0, length = insertions.length; i < length; i++) {
            let item = insertions[i];
            if (Array.isArray(item)) {
                appendChildren(parentSelector, item, main);
            }
            else {
                if (item !== null && item !== undefined) {
                    if (!item.hasOwnProperty('vnodeSelector')) {
                        item = toTextVNode(item);
                    }
                    main.push(item);
                }
            }
        }
    };
    // Render helper functions
    let missingTransition = function () {
        throw new Error('Provide a transitions object to the projectionOptions to do animations');
    };
    const DEFAULT_PROJECTION_OPTIONS = {
        namespace: undefined,
        eventHandlerInterceptor: undefined,
        styleApplyer: function (domNode, styleName, value) {
            // Provides a hook to add vendor prefixes for browsers that still need it.
            domNode.style[styleName] = value;
        },
        transitions: {
            enter: missingTransition,
            exit: missingTransition
        }
    };
    let applyDefaultProjectionOptions = (projectorOptions) => {
        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);
    };
    let checkStyleValue = (styleValue) => {
        if (typeof styleValue !== 'string') {
            throw new Error('Style values must be strings');
        }
    };
    let setProperties = function (domNode, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        let eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;
        let propNames = Object.keys(properties);
        let propCount = propNames.length;
        for (let i = 0; i < propCount; i++) {
            let propName = propNames[i];
            /* tslint:disable:no-var-keyword: edge case */
            let propValue = properties[propName];
            /* tslint:enable:no-var-keyword */
            if (propName === 'className') {
                throw new Error('Property "className" is not supported, use "class".');
            }
            else if (propName === 'class') {
                propValue.split(/\s+/).forEach(token => domNode.classList.add(token));
            }
            else if (propName === 'classes') {
                // object with string keys and boolean values
                let classNames = Object.keys(propValue);
                let classNameCount = classNames.length;
                for (let j = 0; j < classNameCount; j++) {
                    let className = classNames[j];
                    if (propValue[className]) {
                        domNode.classList.add(className);
                    }
                }
            }
            else if (propName === 'styles') {
                // object with string keys and string (!) values
                let styleNames = Object.keys(propValue);
                let styleCount = styleNames.length;
                for (let j = 0; j < styleCount; j++) {
                    let styleName = styleNames[j];
                    let styleValue = propValue[styleName];
                    if (styleValue) {
                        checkStyleValue(styleValue);
                        projectionOptions.styleApplyer(domNode, styleName, styleValue);
                    }
                }
            }
            else if (propName !== 'key' && propValue !== null && propValue !== undefined) {
                let type = typeof propValue;
                if (type === 'function') {
                    if (propName.lastIndexOf('on', 0) === 0) {
                        if (eventHandlerInterceptor) {
                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers
                        }
                        if (propName === 'oninput') {
                            (function () {
                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput
                                let oldPropValue = propValue;
                                propValue = function (evt) {
                                    evt.target['oninput-value'] = evt.target.value; // may be HTMLTextAreaElement as well
                                    oldPropValue.apply(this, [evt]);
                                };
                            }());
                        }
                        domNode[propName] = propValue;
                    }
                }
                else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {
                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                    }
                    else {
                        domNode.setAttribute(propName, propValue);
                    }
                }
                else {
                    domNode[propName] = propValue;
                }
            }
        }
    };
    let updateProperties = function (domNode, previousProperties, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        let propertiesUpdated = false;
        let propNames = Object.keys(properties);
        let propCount = propNames.length;
        for (let i = 0; i < propCount; i++) {
            let propName = propNames[i];
            // assuming that properties will be nullified instead of missing is by design
            let propValue = properties[propName];
            let previousValue = previousProperties[propName];
            if (propName === 'class') {
                if (previousValue !== propValue) {
                    throw new Error('"class" property may not be updated. Use the "classes" property for conditional css classes.');
                }
            }
            else if (propName === 'classes') {
                let classList = domNode.classList;
                let classNames = Object.keys(propValue);
                let classNameCount = classNames.length;
                for (let j = 0; j < classNameCount; j++) {
                    let className = classNames[j];
                    let on = !!propValue[className];
                    let previousOn = !!previousValue[className];
                    if (on === previousOn) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (on) {
                        classList.add(className);
                    }
                    else {
                        classList.remove(className);
                    }
                }
            }
            else if (propName === 'styles') {
                let styleNames = Object.keys(propValue);
                let styleCount = styleNames.length;
                for (let j = 0; j < styleCount; j++) {
                    let styleName = styleNames[j];
                    let newStyleValue = propValue[styleName];
                    let oldStyleValue = previousValue[styleName];
                    if (newStyleValue === oldStyleValue) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (newStyleValue) {
                        checkStyleValue(newStyleValue);
                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);
                    }
                    else {
                        projectionOptions.styleApplyer(domNode, styleName, '');
                    }
                }
            }
            else {
                if (!propValue && typeof previousValue === 'string') {
                    propValue = '';
                }
                if (propName === 'value') {
                    let domValue = domNode[propName];
                    if (domValue !== propValue // The 'value' in the DOM tree !== newValue
                        && (domNode['oninput-value']
                            ? domValue === domNode['oninput-value'] // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput
                            : propValue !== previousValue // Only update the value if the vdom changed
                        )) {
                        domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change
                        domNode['oninput-value'] = undefined;
                    } // else do not update the domNode, otherwise the cursor position would be changed
                    if (propValue !== previousValue) {
                        propertiesUpdated = true;
                    }
                }
                else if (propValue !== previousValue) {
                    let type = typeof propValue;
                    if (type === 'function') {
                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +
                            '). Hint: declare event handler functions outside the render() function.');
                    }
                    if (type === 'string' && propName !== 'innerHTML') {
                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                        }
                        else if (propName === 'role' && propValue === '') {
                            domNode.removeAttribute(propName);
                        }
                        else {
                            domNode.setAttribute(propName, propValue);
                        }
                    }
                    else {
                        if (domNode[propName] !== propValue) {
                            domNode[propName] = propValue;
                        }
                    }
                    propertiesUpdated = true;
                }
            }
        }
        return propertiesUpdated;
    };
    let findIndexOfChild = function (children, sameAs, start) {
        if (sameAs.vnodeSelector !== '') {
            // Never scan for text-nodes
            for (let i = start; i < children.length; i++) {
                if (same(children[i], sameAs)) {
                    return i;
                }
            }
        }
        return -1;
    };
    let nodeAdded = function (vNode, transitions) {
        if (vNode.properties) {
            let enterAnimation = vNode.properties.enterAnimation;
            if (enterAnimation) {
                if (typeof enterAnimation === 'function') {
                    enterAnimation(vNode.domNode, vNode.properties);
                }
                else {
                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);
                }
            }
        }
    };
    let nodeToRemove = function (vNode, transitions) {
        let domNode = vNode.domNode;
        if (vNode.properties) {
            let exitAnimation = vNode.properties.exitAnimation;
            if (exitAnimation) {
                domNode.style.pointerEvents = 'none';
                let removeDomNode = function () {
                    if (domNode.parentNode) {
                        domNode.parentNode.removeChild(domNode);
                    }
                };
                if (typeof exitAnimation === 'function') {
                    exitAnimation(domNode, removeDomNode, vNode.properties);
                    return;
                }
                else {
                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);
                    return;
                }
            }
        }
        if (domNode.parentNode) {
            domNode.parentNode.removeChild(domNode);
        }
    };
    let checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {
        let childNode = childNodes[indexToCheck];
        if (childNode.vnodeSelector === '') {
            return; // Text nodes need not be distinguishable
        }
        let properties = childNode.properties;
        let key = properties ? (properties.key === undefined ? properties.bind : properties.key) : undefined;
        if (!key) {
            for (let i = 0; i < childNodes.length; i++) {
                if (i !== indexToCheck) {
                    let node = childNodes[i];
                    if (same(node, childNode)) {
                        if (operation === 'added') {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +
                                'added, but there is now more than one. You must add unique key properties to make them distinguishable.');
                        }
                        else {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +
                                'removed, but there were more than one. You must add unique key properties to make them distinguishable.');
                        }
                    }
                }
            }
        }
    };
    let createDom;
    let updateDom;
    let updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {
        if (oldChildren === newChildren) {
            return false;
        }
        oldChildren = oldChildren || emptyArray;
        newChildren = newChildren || emptyArray;
        let oldChildrenLength = oldChildren.length;
        let newChildrenLength = newChildren.length;
        let transitions = projectionOptions.transitions;
        let oldIndex = 0;
        let newIndex = 0;
        let i;
        let textUpdated = false;
        while (newIndex < newChildrenLength) {
            let oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;
            let newChild = newChildren[newIndex];
            if (oldChild !== undefined && same(oldChild, newChild)) {
                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;
                oldIndex++;
            }
            else {
                let findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);
                if (findOldIndex >= 0) {
                    // Remove preceding missing children
                    for (i = oldIndex; i < findOldIndex; i++) {
                        nodeToRemove(oldChildren[i], transitions);
                        checkDistinguishable(oldChildren, i, vnode, 'removed');
                    }
                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;
                    oldIndex = findOldIndex + 1;
                }
                else {
                    // New child
                    createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);
                    nodeAdded(newChild, transitions);
                    checkDistinguishable(newChildren, newIndex, vnode, 'added');
                }
            }
            newIndex++;
        }
        if (oldChildrenLength > oldIndex) {
            // Remove child fragments
            for (i = oldIndex; i < oldChildrenLength; i++) {
                nodeToRemove(oldChildren[i], transitions);
                checkDistinguishable(oldChildren, i, vnode, 'removed');
            }
        }
        return textUpdated;
    };
    let addChildren = function (domNode, children, projectionOptions) {
        if (!children) {
            return;
        }
        for (let i = 0; i < children.length; i++) {
            createDom(children[i], domNode, undefined, projectionOptions);
        }
    };
    let initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {
        addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.
        if (vnode.text) {
            domNode.textContent = vnode.text;
        }
        setProperties(domNode, vnode.properties, projectionOptions);
        if (vnode.properties && vnode.properties.afterCreate) {
            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);
        }
    };
    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {
        let domNode, i, c, start = 0, type, found;
        let vnodeSelector = vnode.vnodeSelector;
        if (vnodeSelector === '') {
            domNode = vnode.domNode = document.createTextNode(vnode.text);
            if (insertBefore !== undefined) {
                parentNode.insertBefore(domNode, insertBefore);
            }
            else {
                parentNode.appendChild(domNode);
            }
        }
        else {
            for (i = 0; i <= vnodeSelector.length; ++i) {
                c = vnodeSelector.charAt(i);
                if (i === vnodeSelector.length || c === '.' || c === '#') {
                    type = vnodeSelector.charAt(start - 1);
                    found = vnodeSelector.slice(start, i);
                    if (type === '.') {
                        domNode.classList.add(found);
                    }
                    else if (type === '#') {
                        domNode.id = found;
                    }
                    else {
                        if (found === 'svg') {
                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
                        }
                        if (projectionOptions.namespace !== undefined) {
                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);
                        }
                        else {
                            domNode = vnode.domNode = document.createElement(found);
                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {
                                // IE8 and older don't support setting input type after the DOM Node has been added to the document
                                domNode.setAttribute("type", vnode.properties.type);
                            }
                        }
                        if (insertBefore !== undefined) {
                            parentNode.insertBefore(domNode, insertBefore);
                        }
                        else {
                            parentNode.appendChild(domNode);
                        }
                    }
                    start = i + 1;
                }
            }
            initPropertiesAndChildren(domNode, vnode, projectionOptions);
        }
    };
    updateDom = function (previous, vnode, projectionOptions) {
        let domNode = previous.domNode;
        let textUpdated = false;
        if (previous === vnode) {
            return false; // By contract, VNode objects may not be modified anymore after passing them to maquette
        }
        let updated = false;
        if (vnode.vnodeSelector === '') {
            if (vnode.text !== previous.text) {
                let newVNode = document.createTextNode(vnode.text);
                domNode.parentNode.replaceChild(newVNode, domNode);
                vnode.domNode = newVNode;
                textUpdated = true;
                return textUpdated;
            }
        }
        else {
            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {
                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
            }
            if (previous.text !== vnode.text) {
                updated = true;
                if (vnode.text === undefined) {
                    domNode.removeChild(domNode.firstChild); // the only textnode presumably
                }
                else {
                    domNode.textContent = vnode.text;
                }
            }
            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;
            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;
            if (vnode.properties && vnode.properties.afterUpdate) {
                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);
            }
        }
        if (updated && vnode.properties && vnode.properties.updateAnimation) {
            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);
        }
        vnode.domNode = previous.domNode;
        return textUpdated;
    };
    let createProjection = function (vnode, projectionOptions) {
        return {
            update: function (updatedVnode) {
                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {
                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');
                }
                updateDom(vnode, updatedVnode, projectionOptions);
                vnode = updatedVnode;
            },
            domNode: vnode.domNode
        };
    };
    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.
    exports.h = function (selector) {
        let properties = arguments[1];
        if (typeof selector !== 'string') {
            throw new Error();
        }
        let childIndex = 1;
        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {
            childIndex = 2;
        }
        else {
            // Optional properties argument was omitted
            properties = undefined;
        }
        let text;
        let children;
        let argsLength = arguments.length;
        // Recognize a common special case where there is only a single text node
        if (argsLength === childIndex + 1) {
            let onlyChild = arguments[childIndex];
            if (typeof onlyChild === 'string') {
                text = onlyChild;
            }
            else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {
                text = onlyChild[0];
            }
        }
        if (text === undefined) {
            children = [];
            for (; childIndex < argsLength; childIndex++) {
                let child = arguments[childIndex];
                if (child === null || child === undefined) {
                }
                else if (Array.isArray(child)) {
                    appendChildren(selector, child, children);
                }
                else if (child.hasOwnProperty('vnodeSelector')) {
                    children.push(child);
                }
                else {
                    children.push(toTextVNode(child));
                }
            }
        }
        return {
            vnodeSelector: selector,
            properties: properties,
            children: children,
            text: (text === '') ? undefined : text,
            domNode: null
        };
    };
    /**
     * Contains simple low-level utility functions to manipulate the real DOM.
     */
    exports.dom = {
        /**
         * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in
         * its [[Projection.domNode|domNode]] property.
         * This is a low-level method. Users will typically use a [[Projector]] instead.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
         * objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the projection.
         * @returns The [[Projection]] which also contains the DOM Node that was created.
         */
        create: function (vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, document.createElement('div'), undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Appends a new child node to the DOM which is generated from a [[VNode]].
         * This is a low-level method. Users will typically use a [[Projector]] instead.
         * @param parentNode - The parent node for the new child node.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
         * objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the [[Projection]].
         * @returns The [[Projection]] that was created.
         */
        append: function (parentNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, parentNode, undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Inserts a new DOM node which is generated from a [[VNode]].
         * This is a low-level method. Users wil typically use a [[Projector]] instead.
         * @param beforeNode - The node that the DOM Node is inserted before.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.
         * NOTE: [[VNode]] objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
         * @returns The [[Projection]] that was created.
         */
        insertBefore: function (beforeNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.
         * This means that the virtual DOM and the real DOM will have one overlapping element.
         * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.
         * This is a low-level method. Users wil typically use a [[Projector]] instead.
         * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects
         * may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
         * @returns The [[Projection]] that was created.
         */
        merge: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            vnode.domNode = element;
            initPropertiesAndChildren(element, vnode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Replaces an existing DOM node with a node generated from a [[VNode]].
         * This is a low-level method. Users will typically use a [[Projector]] instead.
         * @param element - The node for the [[VNode]] to replace.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
         * objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the [[Projection]].
         * @returns The [[Projection]] that was created.
         */
        replace: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, element.parentNode, element, projectionOptions);
            element.parentNode.removeChild(element);
            return createProjection(vnode, projectionOptions);
        }
    };
    /**
     * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.
     * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.
     * For more information, see [[CalculationCache]].
     *
     * @param <Result> The type of the value that is cached.
     */
    exports.createCache = () => {
        let cachedInputs;
        let cachedOutcome;
        return {
            invalidate: function () {
                cachedOutcome = undefined;
                cachedInputs = undefined;
            },
            result: function (inputs, calculation) {
                if (cachedInputs) {
                    for (let i = 0; i < inputs.length; i++) {
                        if (cachedInputs[i] !== inputs[i]) {
                            cachedOutcome = undefined;
                        }
                    }
                }
                if (!cachedOutcome) {
                    cachedOutcome = calculation();
                    cachedInputs = inputs;
                }
                return cachedOutcome;
            }
        };
    };
    /**
     * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.
     * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.
     *
     * @param <Source>       The type of source items. A database-record for instance.
     * @param <Target>       The type of target items. A [[Component]] for instance.
     * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.
     * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical
     *                       to the `callback` argument in `Array.map(callback)`.
     * @param updateResult   `function(source, target, index)` that updates a result to an updated source.
     */
    exports.createMapping = (getSourceKey, createResult, updateResult) => {
        let keys = [];
        let results = [];
        return {
            results: results,
            map: function (newSources) {
                let newKeys = newSources.map(getSourceKey);
                let oldTargets = results.slice();
                let oldIndex = 0;
                for (let i = 0; i < newSources.length; i++) {
                    let source = newSources[i];
                    let sourceKey = newKeys[i];
                    if (sourceKey === keys[oldIndex]) {
                        results[i] = oldTargets[oldIndex];
                        updateResult(source, oldTargets[oldIndex], i);
                        oldIndex++;
                    }
                    else {
                        let found = false;
                        for (let j = 1; j < keys.length + 1; j++) {
                            let searchIndex = (oldIndex + j) % keys.length;
                            if (keys[searchIndex] === sourceKey) {
                                results[i] = oldTargets[searchIndex];
                                updateResult(newSources[i], oldTargets[searchIndex], i);
                                oldIndex = searchIndex + 1;
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            results[i] = createResult(source, i);
                        }
                    }
                }
                results.length = newSources.length;
                keys = newKeys;
            }
        };
    };
    /**
     * Creates a [[Projector]] instance using the provided projectionOptions.
     *
     * For more information, see [[Projector]].
     *
     * @param projectorOptions   Options that influence how the DOM is rendered and updated.
     */
    exports.createProjector = function (projectorOptions) {
        let projector;
        let projectionOptions = applyDefaultProjectionOptions(projectorOptions);
        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {
            return function () {
                // intercept function calls (event handlers) to do a render afterwards.
                projector.scheduleRender();
                return eventHandler.apply(properties.bind || this, arguments);
            };
        };
        let renderCompleted = true;
        let scheduled;
        let stopped = false;
        let projections = [];
        let renderFunctions = []; // matches the projections array
        let doRender = function () {
            scheduled = undefined;
            if (!renderCompleted) {
                return; // The last render threw an error, it should be logged in the browser console.
            }
            renderCompleted = false;
            for (let i = 0; i < projections.length; i++) {
                let updatedVnode = renderFunctions[i]();
                projections[i].update(updatedVnode);
            }
            renderCompleted = true;
        };
        projector = {
            renderNow: doRender,
            scheduleRender: function () {
                if (!scheduled && !stopped) {
                    scheduled = requestAnimationFrame(doRender);
                }
            },
            stop: function () {
                if (scheduled) {
                    cancelAnimationFrame(scheduled);
                    scheduled = undefined;
                }
                stopped = true;
            },
            resume: function () {
                stopped = false;
                renderCompleted = true;
                projector.scheduleRender();
            },
            append: function (parentNode, renderMaquetteFunction) {
                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            insertBefore: function (beforeNode, renderMaquetteFunction) {
                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            merge: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            replace: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.replace(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            detach: function (renderMaquetteFunction) {
                for (let i = 0; i < renderFunctions.length; i++) {
                    if (renderFunctions[i] === renderMaquetteFunction) {
                        renderFunctions.splice(i, 1);
                        return projections.splice(i, 1)[0];
                    }
                }
                throw new Error('renderMaquetteFunction was not found');
            }
        };
        return projector;
    };
});
define("utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function commas(x) {
        if (typeof x === 'string') {
            return x;
        }
        return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    exports.commas = commas;
    function satsub(a, b) {
        return Math.max(a - b, 0);
    }
    exports.satsub = satsub;
    function unwrapInt(func) {
        return function (ev) {
            let target = ev.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            return func(parseInt(target.value));
        };
    }
    exports.unwrapInt = unwrapInt;
});
define("depressing_state", ["require", "exports", "utils", "depressing_data"], function (require, exports, utils_1, depressing_data_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DepressingState {
        constructor() {
            this.age = 18;
            this.sex = Math.random() > 0.5 ? 'male' : 'female';
            this.cash = 0;
            this.salary = 28458;
            this.capital_gains = 0;
            this.invested = 0;
            this.debt = 0;
            this.expenses = depressing_data_1.VERY_DEPRESSING_DATA.cost_of_living;
            this.dead = false;
            this.logger = new DepressingLog();
            this.proposed = new ProposedState(this);
        }
    }
    exports.DepressingState = DepressingState;
    class ProposedState {
        constructor(actualState) {
            this.reset(actualState);
        }
        reset(actualState) {
            this.cash = actualState.cash;
            this.debt = actualState.debt;
            this.pay_debt = Math.min(this.cash, 12);
            this.invest = Math.min(12, utils_1.satsub(this.cash, this.pay_debt));
        }
    }
    exports.ProposedState = ProposedState;
    class DepressingLog {
        constructor() {
            this._log = [];
        }
        record(age, message) {
            this._log.unshift({ m: message, id: Math.random(), age });
        }
        allLogs() {
            return this._log;
        }
    }
    exports.DepressingLog = DepressingLog;
});
define("new_hotness", ["require", "exports", "depressing_state", "utils", "depressing_data"], function (require, exports, depressing_state_1, utils_2, depressing_data_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Person {
        constructor(name) {
            this.cash = new CashAccount();
            this.investments = [];
            this.debts = [];
            this.dead = false;
            this.age = 18;
            this.job = new Job(this, depressing_data_2.VERY_DEPRESSING_DATA.cost_of_living);
            this.hedons = 0;
            this.dolors = 0;
            this.logger = new depressing_state_1.DepressingLog();
            this.name = name;
            this.logger = new depressing_state_1.DepressingLog();
        }
        log(message) {
            this.logger.record(this.age, message);
        }
    }
    exports.Person = Person;
    class Account {
        constructor(opts) {
            this.name = opts.name;
            this._balance = opts.startingBalance || 0;
            this.minBalance = opts.minBalance || 0;
            this.maxBalance = opts.maxBalance || Infinity;
            this.interestRate = opts.interestRate || 0;
            this.parent = null;
        }
        get balance() {
            return this._balance;
        }
        makeProposal() {
            // Escape from type safety
            let proposed = new (this.constructor(this));
            proposed.parent = this;
            return proposed;
        }
    }
    exports.Account = Account;
    class CashAccount extends Account {
        constructor() {
            super({ name: 'cash' });
        }
    }
    exports.CashAccount = CashAccount;
    class CreditAccount extends Account {
        constructor({ name, minBalance, interestRate, canIncrease }) {
            super({ maxBalance: 0, name, minBalance, interestRate });
            this.canIncrease = canIncrease;
        }
        availableDebt() {
            if (!this.canIncrease) {
                return 0;
            }
            else {
                return this.balance - this.minBalance;
            }
        }
    }
    exports.CreditAccount = CreditAccount;
    class InvestmentAccount extends Account {
        constructor(opts) {
            super(opts);
        }
    }
    exports.InvestmentAccount = InvestmentAccount;
    class Job {
        constructor(worker, salary) {
            this.salary = salary;
            this.worker = worker;
            this.jobStability = 0.90;
        }
        salaryReview() {
            if (Math.random() > this.jobStability) {
                let lossPercent = 1 - Math.random() * 0.04;
                this.salary = Math.round(this.salary * lossPercent);
                this.worker.log(`You were fired and got a new job at a lower salary: $${utils_2.commas(this.salary)}`);
            }
            else {
                let raisePercent = 1 + Math.random() * 0.14;
                this.salary = Math.round(this.salary * raisePercent);
                this.worker.log(`You received a large raise to: $${utils_2.commas(this.salary)}`);
            }
        }
    }
    exports.Job = Job;
    class Item {
    }
    exports.Item = Item;
    class SpendingProposal {
        constructor(person) {
            this.purchases = [];
            this.cash = person.cash.makeProposal();
            this.investments = person.investments.map(i => i.makeProposal());
            this.debts = person.debts.map(d => d.makeProposal());
            this.startingTotal = this.proposalSum();
        }
        currentDebt() {
            return this.debts.reduce((total, d) => total + d.balance, 0);
        }
        availableDebt() {
            return this.debts.reduce((total, d) => total + d.availableDebt(), 0);
        }
        totalInvestments() {
            return this.investments.reduce((total, i) => total + i.balance, 0);
        }
        purchasesPrice() {
            return -this.purchases.reduce((total, i) => total + i.price, 0);
        }
        proposalSum() {
            return this.availableDebt() +
                this.currentDebt() +
                this.cash.balance +
                this.totalInvestments() +
                this.purchasesPrice();
        }
        sanityCheck() {
            this.proposalSum() === this.startingTotal;
        }
    }
    exports.SpendingProposal = SpendingProposal;
});
define("depressing_logic", ["require", "exports", "utils", "depressing_data", "new_hotness"], function (require, exports, utils_3, depressing_data_3, new_hotness_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class GameLogic {
        constructor(state) {
            this.state = state;
            this.person_deleteme = new new_hotness_1.Person('Johnny');
        }
        broadcast(sa) {
            switch (sa.kind) {
                case 'advance_year':
                    this.advanceYear();
                    break;
                case 'propose_investment':
                    this.updateInvest(sa.investAmount);
                    break;
                case 'propose_debt_payment':
                    this.updatePayDebt(sa.debtAmount);
                    break;
                case 'log':
                    this.log(sa.message);
                    break;
            }
        }
        broadcaster() {
            return this.broadcast.bind(this);
        }
        advanceYear() {
            this.state.age += 1;
            this.doInvestment();
            this.doDebt();
            this.updateCash();
            this.updateSalary();
            this.updateCapitalGains();
            this.updateExpenses();
            this.state.proposed.reset(this.state);
            this.decideIfDead();
        }
        doInvestment() {
            if (this.state.proposed.invest > 0) {
                this.state.cash -= this.state.proposed.invest;
                this.state.invested += this.state.proposed.invest;
            }
        }
        doDebt() {
            if (this.state.proposed.pay_debt > 0) {
                this.state.cash -= this.state.proposed.pay_debt;
                this.state.debt += this.state.proposed.pay_debt;
            }
            this.state.debt = Math.round(this.state.debt * 1.04);
        }
        updateCash() {
            this.state.cash += this.state.salary + this.state.capital_gains;
            if (this.state.expenses > this.state.cash) {
                let shortfall = this.state.expenses - this.state.cash;
                this.state.cash = 0;
                if (shortfall > this.state.invested) {
                    let debt = shortfall - this.state.invested;
                    if (this.state.invested > 0) {
                        this.log(`Had to go into debt -$${utils_3.commas(debt)}. Savings wiped out.`);
                        this.state.invested = 0;
                    }
                    else {
                        this.log(`Had to go into debt -$${utils_3.commas(debt)}.`);
                    }
                    this.state.debt -= debt;
                }
                else {
                    this.log(`Not enough cash for expenses. Eating into investment principle $${utils_3.commas(shortfall)}.`);
                    this.state.invested -= shortfall;
                }
            }
            else {
                this.state.cash -= this.state.expenses;
            }
        }
        updateSalary() {
            let raisePercent = 1 + Math.random() * 0.16 - 0.04;
            this.state.salary = Math.round(this.state.salary * raisePercent);
            if (raisePercent > 1.09) {
                this.log(`You received a large raise to: $${utils_3.commas(this.state.salary)}`);
            }
            else if (raisePercent < 1) {
                this.log(`You were fired and got a new job at a lower salary: $${utils_3.commas(this.state.salary)}`);
            }
        }
        updateCapitalGains() {
            this.state.capital_gains = Math.round(this.state.invested * 0.05);
        }
        updateExpenses() {
            this.state.expenses = Math.round(this.state.expenses * (1 + depressing_data_3.VERY_DEPRESSING_DATA.inflation));
        }
        decideIfDead() {
            if (Math.random() <=
                depressing_data_3.VERY_DEPRESSING_DATA.death_rates[this.state.age][this.state.sex]) {
                this.state.dead = true;
            }
        }
        log(message) {
            this.state.logger.record(this.state.age, message);
        }
        updateInvest(investAmount) {
            this.state.proposed.invest = investAmount;
            let ready_cash = this.state.proposed.cash - this.state.proposed.pay_debt;
            if (investAmount > ready_cash) {
                this.state.proposed.pay_debt += ready_cash - investAmount;
            }
        }
        updatePayDebt(debtAmount) {
            this.state.proposed.pay_debt = debtAmount;
            let ready_cash = this.state.proposed.cash - this.state.proposed.invest;
            if (debtAmount > ready_cash) {
                this.state.proposed.invest += ready_cash - debtAmount;
            }
        }
    }
    exports.GameLogic = GameLogic;
});
define("depressing_ui", ["require", "exports", "third-party/maquette", "utils"], function (require, exports, maquette_1, utils_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Component {
        constructor(state, broadcast) {
            this.state = state;
            this.broadcast = broadcast;
            this.uistate = this.initUIState();
        }
    }
    exports.Component = Component;
    class SimpleComponent extends Component {
        initUIState() { return null; }
    }
    exports.SimpleComponent = SimpleComponent;
    class ConstComponent extends SimpleComponent {
    }
    exports.ConstComponent = ConstComponent;
    class FullGameComponent extends SimpleComponent {
        constructor(state, broadcast) {
            super(state, broadcast);
            this.outputList = new OutputListComponent(this.state, broadcast);
            this.inputForm = new InputFormComponent(this.state, broadcast);
            this.log = new LogComponent(this.state, broadcast);
        }
        render() {
            return maquette_1.h('div.tile.is-ancestor', { key: this }, [
                // The "is-X" classes have to sum to 12
                maquette_1.h('div.tile.is-parent.is-3', maquette_1.h('div.tile.is-child.box', this.outputList.render())),
                maquette_1.h('div.tile.is-parent.is-3', maquette_1.h('div.tile.is-child.box', this.inputForm.render())),
                maquette_1.h('div.tile.is-parent.is-6', maquette_1.h('div.tile.is-child.box', this.log.render())),
            ]);
        }
    }
    exports.FullGameComponent = FullGameComponent;
    class OutputListComponent extends SimpleComponent {
        render() {
            return maquette_1.h('ul.displays', { key: this }, [
                this.sex(),
                this.age(),
                this.cash(),
                this.expenses(),
                this.salary(),
                this.capitalGains(),
                this.investments(),
                this.debt(),
            ]);
        }
        sex() { return this.makeli('Sex', this.state.sex); }
        age() { return this.makeli('Age', this.state.age); }
        cash() { return this.makeli$('Cash', this.state.cash); }
        expenses() { return this.makeli$('Expenses', this.state.expenses); }
        salary() { return this.makeli$('Salary', this.state.salary); }
        capitalGains() {
            if (this.state.capital_gains <= 0) {
                return;
            }
            return this.makeli$('Capital gains', this.state.capital_gains);
        }
        investments() {
            if (this.state.invested <= 0) {
                return;
            }
            return this.makeli$('Investments', this.state.invested);
        }
        debt() {
            if (this.state.debt >= 0) {
                return;
            }
            return this.makeli$('Debt', this.state.debt);
        }
        makeli$(title, value) {
            return maquette_1.h('li', { key: title }, [`${title}: $${utils_4.commas(value)}`]);
        }
        makeli(title, value) {
            return maquette_1.h('li', { key: title }, [`${title}: ${utils_4.commas(value)}`]);
        }
    }
    exports.OutputListComponent = OutputListComponent;
    class InputFormComponent extends SimpleComponent {
        constructor(state, broadcast) {
            super(state, broadcast);
            this.investForm = new InvestFormComponent(this.state, broadcast);
            this.buttonClick = () => {
                broadcast({ kind: 'advance_year' });
            };
            //this.buttonClick = () => this.state.doRound()
        }
        render() {
            if (this.state.dead) {
                return maquette_1.h('p', maquette_1.h('b', 'You died.'));
            }
            else {
                return maquette_1.h('p', maquette_1.h('a.button.is-danger', { onclick: this.buttonClick }, 'Play the game'), this.investForm.render());
            }
        }
    }
    exports.InputFormComponent = InputFormComponent;
    class InvestFormComponent extends SimpleComponent {
        constructor(state, broadcast) {
            super(state, broadcast);
            this.investUpdate = utils_4.unwrapInt(investAmount => broadcast({
                kind: 'propose_investment',
                investAmount,
            }));
            this.debtUpdate = utils_4.unwrapInt(debtAmount => broadcast({
                kind: 'propose_debt_payment',
                debtAmount
            }));
        }
        render() {
            return maquette_1.h('form', maquette_1.h('div.form-group', this.investSlider(), this.debtSlider()));
        }
        investSlider() {
            if (this.state.cash <= 0) {
                return;
            }
            return maquette_1.h('div.field', maquette_1.h('label', { key: 'label-invest' }, `Invest $${utils_4.commas(this.state.proposed.invest)}`, this.rangeSlider(this.state.proposed, 'invest', this.investUpdate, this.state.cash)));
        }
        debtSlider() {
            if (this.state.cash <= 0 || this.state.debt >= 0) {
                return;
            }
            return maquette_1.h('label', { key: 'label-pay-debt' }, `Pay debt $${utils_4.commas(this.state.proposed.pay_debt)}`, this.rangeSlider(this.state.proposed, 'pay_debt', this.debtUpdate, Math.min(-this.state.debt, this.state.cash)));
        }
        rangeSlider(state, prop, updateFunc, max) {
            return maquette_1.h('div.control', maquette_1.h('input.slider', {
                type: 'range',
                min: 0,
                max,
                step: 1,
                key: prop,
                value: state[prop].toString(),
                oninput: updateFunc,
            }));
        }
    }
    exports.InvestFormComponent = InvestFormComponent;
    class LogComponent extends SimpleComponent {
        render() {
            return maquette_1.h('div.eventlog', this.state.logger.allLogs()
                .map(msg => maquette_1.h('p', { key: msg.id }, maquette_1.h('b', `Age ${msg.age} `), msg.m)));
        }
    }
    exports.LogComponent = LogComponent;
});
define("depressing_game", ["require", "exports", "depressing_data", "depressing_ui", "depressing_state", "depressing_logic", "third-party/maquette"], function (require, exports, depressing_data_4, depressing_ui_1, depressing_state_2, depressing_logic_1, maquette_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DepressingGame {
        constructor() {
            this.data = depressing_data_4.VERY_DEPRESSING_DATA;
            this.state = new depressing_state_2.DepressingState();
            this.gameLogic = new depressing_logic_1.GameLogic(this.state);
            this.broadcaster = this.gameLogic.broadcaster();
            this.fullGame = new depressing_ui_1.FullGameComponent(this.state, this.broadcaster);
        }
        render() {
            return this.fullGame.render();
        }
    }
    // Initialize
    function initialize() {
        let projector = maquette_2.createProjector();
        let rootElem = document.getElementById('game');
        let depressingGame = new DepressingGame();
        if (rootElem !== null) {
            projector.append(rootElem, () => depressingGame.render());
        }
        window.game = depressingGame;
    }
    exports.initialize = initialize;
});
