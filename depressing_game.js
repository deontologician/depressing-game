define("depressing_data", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERY_DEPRESSING_DATA = {
        preamble: "You know how to play",
        inflation: 0.03,
        // http://cost-of-living.careertrends.com/l/615/The-United-States
        cost_of_living: 28458,
        death_rates: {
            18: { male: 0.000735, female: 0.0002978 },
            19: { male: 0.000869, female: 0.0003340 },
            20: { male: 0.001011, female: 0.0003732 },
            21: { male: 0.001145, female: 0.0004125 },
            22: { male: 0.001246, female: 0.0004467 },
            23: { male: 0.001301, female: 0.0004720 },
            24: { male: 0.001321, female: 0.0004932 },
            25: { male: 0.001330, female: 0.0005135 },
            26: { male: 0.001345, female: 0.0005378 },
            27: { male: 0.001363, female: 0.0005631 },
            28: { male: 0.001391, female: 0.0005934 },
            29: { male: 0.001427, female: 0.0006277 },
            30: { male: 0.001467, female: 0.0006641 },
            31: { male: 0.001505, female: 0.0007054 },
            32: { male: 0.001541, female: 0.0007488 },
            33: { male: 0.001573, female: 0.0007941 },
            34: { male: 0.001606, female: 0.0008455 },
            35: { male: 0.001648, female: 0.0009039 },
            36: { male: 0.001704, female: 0.0009683 },
            37: { male: 0.001774, female: 0.0010388 },
            38: { male: 0.001861, female: 0.0011133 },
            39: { male: 0.001967, female: 0.0011967 },
            40: { male: 0.002092, female: 0.0012873 },
            41: { male: 0.002240, female: 0.0013938 },
            42: { male: 0.002418, female: 0.0015174 },
            43: { male: 0.002629, female: 0.0016620 },
            44: { male: 0.002873, female: 0.0018276 },
            45: { male: 0.003146, female: 0.0020053 },
            46: { male: 0.003447, female: 0.0021981 },
            47: { male: 0.003787, female: 0.0024129 },
            48: { male: 0.004167, female: 0.0026487 },
            49: { male: 0.004586, female: 0.0029046 },
            50: { male: 0.005038, female: 0.0031826 },
            51: { male: 0.005520, female: 0.0034737 },
            52: { male: 0.006036, female: 0.0037678 },
            53: { male: 0.006587, female: 0.0040589 },
            54: { male: 0.007170, female: 0.0043522 },
            55: { male: 0.007801, female: 0.0046814 },
            56: { male: 0.008466, female: 0.0050408 },
            57: { male: 0.009133, female: 0.0054001 },
            58: { male: 0.009792, female: 0.0057566 },
            59: { male: 0.010462, female: 0.0061281 },
            60: { male: 0.011197, female: 0.0065456 },
            61: { male: 0.012009, female: 0.0070342 },
            62: { male: 0.012867, female: 0.0076078 },
            63: { male: 0.013772, female: 0.0082815 },
            64: { male: 0.014749, female: 0.0090573 },
            65: { male: 0.015852, female: 0.0099532 },
            66: { male: 0.017097, female: 0.0109502 },
            67: { male: 0.018463, female: 0.0120103 },
            68: { male: 0.019959, female: 0.0131245 },
            69: { male: 0.021616, female: 0.0143308 },
            70: { male: 0.023528, female: 0.0157283 },
            71: { male: 0.025693, female: 0.0173388 },
            72: { male: 0.028041, female: 0.0191085 },
            73: { male: 0.030567, female: 0.0210413 },
            74: { male: 0.033347, female: 0.0231913 },
            75: { male: 0.036572, female: 0.0257133 },
            76: { male: 0.040276, female: 0.0286096 },
            77: { male: 0.044348, female: 0.0317600 },
            78: { male: 0.048797, female: 0.0351576 },
            79: { male: 0.053739, female: 0.0389204 },
            80: { male: 0.059403, female: 0.043289 },
            81: { male: 0.065873, female: 0.048356 },
            82: { male: 0.073082, female: 0.054041 },
            83: { male: 0.081070, female: 0.060384 },
            84: { male: 0.089947, female: 0.067498 },
            85: { male: 0.099842, female: 0.075516 },
            86: { male: 0.110863, female: 0.084556 },
            87: { male: 0.123088, female: 0.094703 },
            88: { male: 0.136563, female: 0.106014 },
            89: { male: 0.151299, female: 0.118513 },
            90: { male: 0.167291, female: 0.132206 },
            91: { male: 0.184520, female: 0.147092 },
            92: { male: 0.202954, female: 0.163154 },
            93: { male: 0.222555, female: 0.180371 },
            94: { male: 0.243272, female: 0.198714 },
            95: { male: 0.263821, female: 0.217264 },
            96: { male: 0.283833, female: 0.235735 },
            97: { male: 0.302916, female: 0.253810 },
            98: { male: 0.320672, female: 0.271155 },
            99: { male: 0.336706, female: 0.287424 },
            100: { male: 0.353541, female: 0.304670 },
            101: { male: 0.371218, female: 0.322950 },
            102: { male: 0.389779, female: 0.342327 },
            103: { male: 0.409268, female: 0.362867 },
            104: { male: 0.429732, female: 0.384639 },
            105: { male: 0.451218, female: 0.407717 },
            106: { male: 0.473779, female: 0.432180 },
            107: { male: 0.497468, female: 0.458111 },
            108: { male: 0.522341, female: 0.485597 },
            109: { male: 0.548458, female: 0.514733 },
            110: { male: 0.575881, female: 0.545617 },
            111: { male: 0.604675, female: 0.578354 },
            112: { male: 0.634909, female: 0.613055 },
            113: { male: 0.666655, female: 0.649839 },
            114: { male: 0.699987, female: 0.688829 },
            115: { male: 0.734987, female: 0.730159 },
            116: { male: 0.771736, female: 0.771736 },
            117: { male: 0.810323, female: 0.810323 },
            118: { male: 0.850839, female: 0.850839 },
            119: { male: 0.893381, female: 0.893381 },
        },
        // Reasons for getting fired
        reasons_for_termination: [
            "Let the llamas out, again.",
            "Slept with boss's spouse.",
            "Punched HR director.",
            "Stole money from the cash register.",
            "Yelled at customer.",
            "Screwed up the big account, lost millions for the company.",
            "Sleeping on the job.",
            "Downsized.",
            "Lost the company car.",
            "Bad at your job.",
            "Stole the stapler from your job.",
            "Took too much time off from work.",
            "Yelled at your boss.",
            "Caught with booze at work.",
            "You don't fit in with company culture.",
            "Your paranoia got you fired. You thought this would happen.",
            "Caught doodling at work.",
            "Poor file management.",
            "Stress eating from the vending machine.",
            "Stole money from the vault.",
            "Stole someone else's lunch from the fridge.",
            "Unable to understand elevators.",
            "Not a team player.",
            "Reading too much Reddit.",
            "Operating a ponzi scheme from the office.",
            "You are the office gossip.",
            "You are the source of office gossip.",
            "Spending too much time on Facebook.",
        ],
    };
});
// Comment that is displayed in the API documentation for the maquette module:
/**
 * Welcome to the API documentation of the **maquette** library.
 *
 * [[http://maquettejs.org/|To the maquette homepage]]
 */
define("third-party/maquette", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NAMESPACE_W3 = 'http://www.w3.org/';
    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';
    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';
    // Utilities
    var emptyArray = [];
    var extend = function (base, overrides) {
        var result = {};
        Object.keys(base).forEach(function (key) {
            result[key] = base[key];
        });
        if (overrides) {
            Object.keys(overrides).forEach(function (key) {
                result[key] = overrides[key];
            });
        }
        return result;
    };
    // Hyperscript helper functions
    var same = function (vnode1, vnode2) {
        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {
            return false;
        }
        if (vnode1.properties && vnode2.properties) {
            if (vnode1.properties.key !== vnode2.properties.key) {
                return false;
            }
            return vnode1.properties.bind === vnode2.properties.bind;
        }
        return !vnode1.properties && !vnode2.properties;
    };
    var toTextVNode = function (data) {
        return {
            vnodeSelector: '',
            properties: undefined,
            children: undefined,
            text: data.toString(),
            domNode: null
        };
    };
    var appendChildren = function (parentSelector, insertions, main) {
        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {
            var item = insertions[i];
            if (Array.isArray(item)) {
                appendChildren(parentSelector, item, main);
            }
            else {
                if (item !== null && item !== undefined) {
                    if (!item.hasOwnProperty('vnodeSelector')) {
                        item = toTextVNode(item);
                    }
                    main.push(item);
                }
            }
        }
    };
    // Render helper functions
    var missingTransition = function () {
        throw new Error('Provide a transitions object to the projectionOptions to do animations');
    };
    var DEFAULT_PROJECTION_OPTIONS = {
        namespace: undefined,
        eventHandlerInterceptor: undefined,
        styleApplyer: function (domNode, styleName, value) {
            // Provides a hook to add vendor prefixes for browsers that still need it.
            domNode.style[styleName] = value;
        },
        transitions: {
            enter: missingTransition,
            exit: missingTransition
        }
    };
    var applyDefaultProjectionOptions = function (projectorOptions) {
        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);
    };
    var checkStyleValue = function (styleValue) {
        if (typeof styleValue !== 'string') {
            throw new Error('Style values must be strings');
        }
    };
    var setProperties = function (domNode, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        var _loop_1 = function (i) {
            var propName = propNames[i];
            /* tslint:disable:no-var-keyword: edge case */
            var propValue = properties[propName];
            /* tslint:enable:no-var-keyword */
            if (propName === 'className') {
                throw new Error('Property "className" is not supported, use "class".');
            }
            else if (propName === 'class') {
                propValue.split(/\s+/).forEach(function (token) { return domNode.classList.add(token); });
            }
            else if (propName === 'classes') {
                // object with string keys and boolean values
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    if (propValue[className]) {
                        domNode.classList.add(className);
                    }
                }
            }
            else if (propName === 'styles') {
                // object with string keys and string (!) values
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var styleValue = propValue[styleName];
                    if (styleValue) {
                        checkStyleValue(styleValue);
                        projectionOptions.styleApplyer(domNode, styleName, styleValue);
                    }
                }
            }
            else if (propName !== 'key' && propValue !== null && propValue !== undefined) {
                var type = typeof propValue;
                if (type === 'function') {
                    if (propName.lastIndexOf('on', 0) === 0) {
                        if (eventHandlerInterceptor) {
                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers
                        }
                        if (propName === 'oninput') {
                            (function () {
                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput
                                var oldPropValue = propValue;
                                propValue = function (evt) {
                                    evt.target['oninput-value'] = evt.target.value; // may be HTMLTextAreaElement as well
                                    oldPropValue.apply(this, [evt]);
                                };
                            }());
                        }
                        domNode[propName] = propValue;
                    }
                }
                else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {
                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                    }
                    else {
                        domNode.setAttribute(propName, propValue);
                    }
                }
                else {
                    domNode[propName] = propValue;
                }
            }
        };
        for (var i = 0; i < propCount; i++) {
            _loop_1(i);
        }
    };
    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var propertiesUpdated = false;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        for (var i = 0; i < propCount; i++) {
            var propName = propNames[i];
            // assuming that properties will be nullified instead of missing is by design
            var propValue = properties[propName];
            var previousValue = previousProperties[propName];
            if (propName === 'class') {
                if (previousValue !== propValue) {
                    throw new Error('"class" property may not be updated. Use the "classes" property for conditional css classes.');
                }
            }
            else if (propName === 'classes') {
                var classList = domNode.classList;
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    var on = !!propValue[className];
                    var previousOn = !!previousValue[className];
                    if (on === previousOn) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (on) {
                        classList.add(className);
                    }
                    else {
                        classList.remove(className);
                    }
                }
            }
            else if (propName === 'styles') {
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var newStyleValue = propValue[styleName];
                    var oldStyleValue = previousValue[styleName];
                    if (newStyleValue === oldStyleValue) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (newStyleValue) {
                        checkStyleValue(newStyleValue);
                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);
                    }
                    else {
                        projectionOptions.styleApplyer(domNode, styleName, '');
                    }
                }
            }
            else {
                if (!propValue && typeof previousValue === 'string') {
                    propValue = '';
                }
                if (propName === 'value') {
                    var domValue = domNode[propName];
                    if (domValue !== propValue // The 'value' in the DOM tree !== newValue
                        && (domNode['oninput-value']
                            ? domValue === domNode['oninput-value'] // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput
                            : propValue !== previousValue // Only update the value if the vdom changed
                        )) {
                        domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change
                        domNode['oninput-value'] = undefined;
                    } // else do not update the domNode, otherwise the cursor position would be changed
                    if (propValue !== previousValue) {
                        propertiesUpdated = true;
                    }
                }
                else if (propValue !== previousValue) {
                    var type = typeof propValue;
                    if (type === 'function') {
                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +
                            '). Hint: declare event handler functions outside the render() function.');
                    }
                    if (type === 'string' && propName !== 'innerHTML') {
                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                        }
                        else if (propName === 'role' && propValue === '') {
                            domNode.removeAttribute(propName);
                        }
                        else {
                            domNode.setAttribute(propName, propValue);
                        }
                    }
                    else {
                        if (domNode[propName] !== propValue) {
                            domNode[propName] = propValue;
                        }
                    }
                    propertiesUpdated = true;
                }
            }
        }
        return propertiesUpdated;
    };
    var findIndexOfChild = function (children, sameAs, start) {
        if (sameAs.vnodeSelector !== '') {
            // Never scan for text-nodes
            for (var i = start; i < children.length; i++) {
                if (same(children[i], sameAs)) {
                    return i;
                }
            }
        }
        return -1;
    };
    var nodeAdded = function (vNode, transitions) {
        if (vNode.properties) {
            var enterAnimation = vNode.properties.enterAnimation;
            if (enterAnimation) {
                if (typeof enterAnimation === 'function') {
                    enterAnimation(vNode.domNode, vNode.properties);
                }
                else {
                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);
                }
            }
        }
    };
    var nodeToRemove = function (vNode, transitions) {
        var domNode = vNode.domNode;
        if (vNode.properties) {
            var exitAnimation = vNode.properties.exitAnimation;
            if (exitAnimation) {
                domNode.style.pointerEvents = 'none';
                var removeDomNode = function () {
                    if (domNode.parentNode) {
                        domNode.parentNode.removeChild(domNode);
                    }
                };
                if (typeof exitAnimation === 'function') {
                    exitAnimation(domNode, removeDomNode, vNode.properties);
                    return;
                }
                else {
                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);
                    return;
                }
            }
        }
        if (domNode.parentNode) {
            domNode.parentNode.removeChild(domNode);
        }
    };
    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {
        var childNode = childNodes[indexToCheck];
        if (childNode.vnodeSelector === '') {
            return; // Text nodes need not be distinguishable
        }
        var properties = childNode.properties;
        var key = properties ? (properties.key === undefined ? properties.bind : properties.key) : undefined;
        if (!key) {
            for (var i = 0; i < childNodes.length; i++) {
                if (i !== indexToCheck) {
                    var node = childNodes[i];
                    if (same(node, childNode)) {
                        if (operation === 'added') {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +
                                'added, but there is now more than one. You must add unique key properties to make them distinguishable.');
                        }
                        else {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +
                                'removed, but there were more than one. You must add unique key properties to make them distinguishable.');
                        }
                    }
                }
            }
        }
    };
    var createDom;
    var updateDom;
    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {
        if (oldChildren === newChildren) {
            return false;
        }
        oldChildren = oldChildren || emptyArray;
        newChildren = newChildren || emptyArray;
        var oldChildrenLength = oldChildren.length;
        var newChildrenLength = newChildren.length;
        var transitions = projectionOptions.transitions;
        var oldIndex = 0;
        var newIndex = 0;
        var i;
        var textUpdated = false;
        while (newIndex < newChildrenLength) {
            var oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;
            var newChild = newChildren[newIndex];
            if (oldChild !== undefined && same(oldChild, newChild)) {
                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;
                oldIndex++;
            }
            else {
                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);
                if (findOldIndex >= 0) {
                    // Remove preceding missing children
                    for (i = oldIndex; i < findOldIndex; i++) {
                        nodeToRemove(oldChildren[i], transitions);
                        checkDistinguishable(oldChildren, i, vnode, 'removed');
                    }
                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;
                    oldIndex = findOldIndex + 1;
                }
                else {
                    // New child
                    createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);
                    nodeAdded(newChild, transitions);
                    checkDistinguishable(newChildren, newIndex, vnode, 'added');
                }
            }
            newIndex++;
        }
        if (oldChildrenLength > oldIndex) {
            // Remove child fragments
            for (i = oldIndex; i < oldChildrenLength; i++) {
                nodeToRemove(oldChildren[i], transitions);
                checkDistinguishable(oldChildren, i, vnode, 'removed');
            }
        }
        return textUpdated;
    };
    var addChildren = function (domNode, children, projectionOptions) {
        if (!children) {
            return;
        }
        for (var i = 0; i < children.length; i++) {
            createDom(children[i], domNode, undefined, projectionOptions);
        }
    };
    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {
        addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.
        if (vnode.text) {
            domNode.textContent = vnode.text;
        }
        setProperties(domNode, vnode.properties, projectionOptions);
        if (vnode.properties && vnode.properties.afterCreate) {
            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);
        }
    };
    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {
        var domNode, i, c, start = 0, type, found;
        var vnodeSelector = vnode.vnodeSelector;
        if (vnodeSelector === '') {
            domNode = vnode.domNode = document.createTextNode(vnode.text);
            if (insertBefore !== undefined) {
                parentNode.insertBefore(domNode, insertBefore);
            }
            else {
                parentNode.appendChild(domNode);
            }
        }
        else {
            for (i = 0; i <= vnodeSelector.length; ++i) {
                c = vnodeSelector.charAt(i);
                if (i === vnodeSelector.length || c === '.' || c === '#') {
                    type = vnodeSelector.charAt(start - 1);
                    found = vnodeSelector.slice(start, i);
                    if (type === '.') {
                        domNode.classList.add(found);
                    }
                    else if (type === '#') {
                        domNode.id = found;
                    }
                    else {
                        if (found === 'svg') {
                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
                        }
                        if (projectionOptions.namespace !== undefined) {
                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);
                        }
                        else {
                            domNode = vnode.domNode = document.createElement(found);
                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {
                                // IE8 and older don't support setting input type after the DOM Node has been added to the document
                                domNode.setAttribute("type", vnode.properties.type);
                            }
                        }
                        if (insertBefore !== undefined) {
                            parentNode.insertBefore(domNode, insertBefore);
                        }
                        else {
                            parentNode.appendChild(domNode);
                        }
                    }
                    start = i + 1;
                }
            }
            initPropertiesAndChildren(domNode, vnode, projectionOptions);
        }
    };
    updateDom = function (previous, vnode, projectionOptions) {
        var domNode = previous.domNode;
        var textUpdated = false;
        if (previous === vnode) {
            return false; // By contract, VNode objects may not be modified anymore after passing them to maquette
        }
        var updated = false;
        if (vnode.vnodeSelector === '') {
            if (vnode.text !== previous.text) {
                var newVNode = document.createTextNode(vnode.text);
                domNode.parentNode.replaceChild(newVNode, domNode);
                vnode.domNode = newVNode;
                textUpdated = true;
                return textUpdated;
            }
        }
        else {
            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {
                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
            }
            if (previous.text !== vnode.text) {
                updated = true;
                if (vnode.text === undefined) {
                    domNode.removeChild(domNode.firstChild); // the only textnode presumably
                }
                else {
                    domNode.textContent = vnode.text;
                }
            }
            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;
            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;
            if (vnode.properties && vnode.properties.afterUpdate) {
                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);
            }
        }
        if (updated && vnode.properties && vnode.properties.updateAnimation) {
            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);
        }
        vnode.domNode = previous.domNode;
        return textUpdated;
    };
    var createProjection = function (vnode, projectionOptions) {
        return {
            update: function (updatedVnode) {
                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {
                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');
                }
                updateDom(vnode, updatedVnode, projectionOptions);
                vnode = updatedVnode;
            },
            domNode: vnode.domNode
        };
    };
    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.
    exports.h = function (selector) {
        var properties = arguments[1];
        if (typeof selector !== 'string') {
            throw new Error();
        }
        var childIndex = 1;
        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {
            childIndex = 2;
        }
        else {
            // Optional properties argument was omitted
            properties = undefined;
        }
        var text;
        var children;
        var argsLength = arguments.length;
        // Recognize a common special case where there is only a single text node
        if (argsLength === childIndex + 1) {
            var onlyChild = arguments[childIndex];
            if (typeof onlyChild === 'string') {
                text = onlyChild;
            }
            else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {
                text = onlyChild[0];
            }
        }
        if (text === undefined) {
            children = [];
            for (; childIndex < argsLength; childIndex++) {
                var child = arguments[childIndex];
                if (child === null || child === undefined) {
                }
                else if (Array.isArray(child)) {
                    appendChildren(selector, child, children);
                }
                else if (child.hasOwnProperty('vnodeSelector')) {
                    children.push(child);
                }
                else {
                    children.push(toTextVNode(child));
                }
            }
        }
        return {
            vnodeSelector: selector,
            properties: properties,
            children: children,
            text: (text === '') ? undefined : text,
            domNode: null
        };
    };
    /**
     * Contains simple low-level utility functions to manipulate the real DOM.
     */
    exports.dom = {
        /**
         * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in
         * its [[Projection.domNode|domNode]] property.
         * This is a low-level method. Users will typically use a [[Projector]] instead.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
         * objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the projection.
         * @returns The [[Projection]] which also contains the DOM Node that was created.
         */
        create: function (vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, document.createElement('div'), undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Appends a new child node to the DOM which is generated from a [[VNode]].
         * This is a low-level method. Users will typically use a [[Projector]] instead.
         * @param parentNode - The parent node for the new child node.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
         * objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the [[Projection]].
         * @returns The [[Projection]] that was created.
         */
        append: function (parentNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, parentNode, undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Inserts a new DOM node which is generated from a [[VNode]].
         * This is a low-level method. Users wil typically use a [[Projector]] instead.
         * @param beforeNode - The node that the DOM Node is inserted before.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.
         * NOTE: [[VNode]] objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
         * @returns The [[Projection]] that was created.
         */
        insertBefore: function (beforeNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.
         * This means that the virtual DOM and the real DOM will have one overlapping element.
         * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.
         * This is a low-level method. Users wil typically use a [[Projector]] instead.
         * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects
         * may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
         * @returns The [[Projection]] that was created.
         */
        merge: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            vnode.domNode = element;
            initPropertiesAndChildren(element, vnode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
         * Replaces an existing DOM node with a node generated from a [[VNode]].
         * This is a low-level method. Users will typically use a [[Projector]] instead.
         * @param element - The node for the [[VNode]] to replace.
         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
         * objects may only be rendered once.
         * @param projectionOptions - Options to be used to create and update the [[Projection]].
         * @returns The [[Projection]] that was created.
         */
        replace: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, element.parentNode, element, projectionOptions);
            element.parentNode.removeChild(element);
            return createProjection(vnode, projectionOptions);
        }
    };
    /**
     * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.
     * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.
     * For more information, see [[CalculationCache]].
     *
     * @param <Result> The type of the value that is cached.
     */
    exports.createCache = function () {
        var cachedInputs;
        var cachedOutcome;
        return {
            invalidate: function () {
                cachedOutcome = undefined;
                cachedInputs = undefined;
            },
            result: function (inputs, calculation) {
                if (cachedInputs) {
                    for (var i = 0; i < inputs.length; i++) {
                        if (cachedInputs[i] !== inputs[i]) {
                            cachedOutcome = undefined;
                        }
                    }
                }
                if (!cachedOutcome) {
                    cachedOutcome = calculation();
                    cachedInputs = inputs;
                }
                return cachedOutcome;
            }
        };
    };
    /**
     * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.
     * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.
     *
     * @param <Source>       The type of source items. A database-record for instance.
     * @param <Target>       The type of target items. A [[Component]] for instance.
     * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.
     * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical
     *                       to the `callback` argument in `Array.map(callback)`.
     * @param updateResult   `function(source, target, index)` that updates a result to an updated source.
     */
    exports.createMapping = function (getSourceKey, createResult, updateResult) {
        var keys = [];
        var results = [];
        return {
            results: results,
            map: function (newSources) {
                var newKeys = newSources.map(getSourceKey);
                var oldTargets = results.slice();
                var oldIndex = 0;
                for (var i = 0; i < newSources.length; i++) {
                    var source = newSources[i];
                    var sourceKey = newKeys[i];
                    if (sourceKey === keys[oldIndex]) {
                        results[i] = oldTargets[oldIndex];
                        updateResult(source, oldTargets[oldIndex], i);
                        oldIndex++;
                    }
                    else {
                        var found = false;
                        for (var j = 1; j < keys.length + 1; j++) {
                            var searchIndex = (oldIndex + j) % keys.length;
                            if (keys[searchIndex] === sourceKey) {
                                results[i] = oldTargets[searchIndex];
                                updateResult(newSources[i], oldTargets[searchIndex], i);
                                oldIndex = searchIndex + 1;
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            results[i] = createResult(source, i);
                        }
                    }
                }
                results.length = newSources.length;
                keys = newKeys;
            }
        };
    };
    /**
     * Creates a [[Projector]] instance using the provided projectionOptions.
     *
     * For more information, see [[Projector]].
     *
     * @param projectorOptions   Options that influence how the DOM is rendered and updated.
     */
    exports.createProjector = function (projectorOptions) {
        var projector;
        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);
        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {
            return function () {
                // intercept function calls (event handlers) to do a render afterwards.
                projector.scheduleRender();
                return eventHandler.apply(properties.bind || this, arguments);
            };
        };
        var renderCompleted = true;
        var scheduled;
        var stopped = false;
        var projections = [];
        var renderFunctions = []; // matches the projections array
        var doRender = function () {
            scheduled = undefined;
            if (!renderCompleted) {
                return; // The last render threw an error, it should be logged in the browser console.
            }
            renderCompleted = false;
            for (var i = 0; i < projections.length; i++) {
                var updatedVnode = renderFunctions[i]();
                projections[i].update(updatedVnode);
            }
            renderCompleted = true;
        };
        projector = {
            renderNow: doRender,
            scheduleRender: function () {
                if (!scheduled && !stopped) {
                    scheduled = requestAnimationFrame(doRender);
                }
            },
            stop: function () {
                if (scheduled) {
                    cancelAnimationFrame(scheduled);
                    scheduled = undefined;
                }
                stopped = true;
            },
            resume: function () {
                stopped = false;
                renderCompleted = true;
                projector.scheduleRender();
            },
            append: function (parentNode, renderMaquetteFunction) {
                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            insertBefore: function (beforeNode, renderMaquetteFunction) {
                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            merge: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            replace: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.replace(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            detach: function (renderMaquetteFunction) {
                for (var i = 0; i < renderFunctions.length; i++) {
                    if (renderFunctions[i] === renderMaquetteFunction) {
                        renderFunctions.splice(i, 1);
                        return projections.splice(i, 1)[0];
                    }
                }
                throw new Error('renderMaquetteFunction was not found');
            }
        };
        return projector;
    };
});
define("depressing_game", ["require", "exports", "depressing_data", "third-party/maquette"], function (require, exports, depressing_data_1, maquette_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function commas(x) {
        if (typeof x === 'string') {
            return x;
        }
        return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    function satsub(a, b) {
        return Math.max(a - b, 0);
    }
    function makeli$(title, value) {
        return maquette_1.h('li', { key: title }, [title + ": $" + commas(value)]);
    }
    function makeli(title, value) {
        return maquette_1.h('li', { key: title }, [title + ": " + commas(value)]);
    }
    var DepressingLog = /** @class */ (function () {
        function DepressingLog() {
            this._log = [];
        }
        DepressingLog.prototype.record = function (age, message) {
            this._log.unshift({ m: message, id: Math.random(), age: age });
        };
        DepressingLog.prototype.allLogs = function () {
            return this._log;
        };
        return DepressingLog;
    }());
    var ProposedState = /** @class */ (function () {
        function ProposedState(actualState) {
            this.reset(actualState);
        }
        ProposedState.prototype.reset = function (actualState) {
            this.cash = actualState.cash;
            this.debt = actualState.debt;
            this.pay_debt = Math.min(this.cash, 12);
            this.invest = Math.min(12, satsub(this.cash, this.pay_debt));
        };
        ProposedState.prototype.updateInvest = function (evt) {
            var target = evt.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            var amount = parseInt(target.value);
            this.invest = amount;
            var ready_cash = this.cash - this.pay_debt;
            if (amount > ready_cash) {
                this.pay_debt += ready_cash - amount;
            }
        };
        ProposedState.prototype.updatePayDebt = function (evt) {
            var target = evt.target;
            if (!(target instanceof HTMLInputElement)) {
                return;
            }
            var amount = parseInt(target.value);
            this.pay_debt = amount;
            var ready_cash = this.cash - this.invest;
            if (amount > ready_cash) {
                this.invest += ready_cash - amount;
            }
        };
        return ProposedState;
    }());
    var DepressingState = /** @class */ (function () {
        function DepressingState() {
            this.buttonText = 'Play the game';
            this.age = 18;
            this.sex = Math.random() > 0.5 ? 'male' : 'female';
            this.cash = 0;
            this.salary = 28458;
            this.capital_gains = 0;
            this.invested = 0;
            this.debt = 0;
            this.expenses = depressing_data_1.VERY_DEPRESSING_DATA.cost_of_living;
            this.dead = false;
            this.logger = new DepressingLog();
            this.proposed = new ProposedState(this);
        }
        DepressingState.prototype.log = function (message) {
            this.logger.record(this.age, message);
        };
        DepressingState.prototype.getLogs = function () {
            return this.logger.allLogs();
        };
        DepressingState.prototype.decideIfDead = function () {
            if (Math.random() <=
                depressing_data_1.VERY_DEPRESSING_DATA.death_rates[this.age][this.sex]) {
                this.dead = true;
            }
        };
        DepressingState.prototype.updateSalary = function () {
            var raisePercent = 1 + Math.random() * 0.16 - 0.04;
            if (raisePercent > 1.09) {
                this.log('You received a large raise');
            }
            else if (raisePercent < 1) {
                this.log('You were fired and got a new job at a lower salary.');
            }
            this.salary = Math.round(this.salary * raisePercent);
        };
        DepressingState.prototype.updateCapitalGains = function () {
            this.capital_gains = Math.round(this.invested * 0.05);
        };
        DepressingState.prototype.doInvestment = function () {
            if (this.proposed.invest > 0) {
                this.cash -= this.proposed.invest;
                this.invested += this.proposed.invest;
            }
        };
        DepressingState.prototype.doDebt = function () {
            if (this.proposed.pay_debt > 0) {
                this.cash -= this.proposed.pay_debt;
                this.debt += this.proposed.pay_debt;
            }
            this.debt = Math.round(this.debt * 1.04);
        };
        DepressingState.prototype.updateCash = function () {
            this.cash += this.salary + this.capital_gains;
            if (this.expenses > this.cash) {
                var shortfall = this.expenses - this.cash;
                this.cash = 0;
                if (shortfall > this.invested) {
                    var debt = shortfall - this.invested;
                    if (this.invested > 0) {
                        this.log("Had to go into debt -$" + commas(debt) + ". Savings wiped out.");
                        this.invested = 0;
                    }
                    else {
                        this.log("Had to go into debt -$" + commas(debt) + ".");
                    }
                    this.debt -= debt;
                }
                else {
                    this.log("Not enough cash for expenses. Eating into investment principle $" + commas(shortfall) + ".");
                    this.invested -= shortfall;
                }
            }
            else {
                this.cash -= this.expenses;
            }
        };
        DepressingState.prototype.updateExpenses = function () {
            this.expenses = Math.round(this.expenses * (1 + depressing_data_1.VERY_DEPRESSING_DATA.inflation));
        };
        DepressingState.prototype.doRound = function () {
            this.age += 1;
            this.doInvestment();
            this.doDebt();
            this.updateCash();
            this.updateSalary();
            this.updateCapitalGains();
            this.updateExpenses();
            this.proposed.reset(this);
            this.decideIfDead();
        };
        return DepressingState;
    }());
    var DepressingGame = /** @class */ (function () {
        function DepressingGame() {
            this.data = depressing_data_1.VERY_DEPRESSING_DATA;
            this.state = new DepressingState();
        }
        DepressingGame.prototype.button = function () {
            return maquette_1.h('a.button.is-danger', {
                onclick: this.state.doRound,
                bind: this.state,
            }, [this.state.buttonText]);
        };
        DepressingGame.prototype.slider = function (prop, updateFunc, max) {
            return maquette_1.h('input.slider', {
                type: 'range',
                min: 0,
                max: max,
                step: 1,
                key: prop,
                value: this.state.proposed[prop].toString(),
                oninput: this.state.proposed[updateFunc],
                bind: this.state.proposed,
            });
        };
        DepressingGame.prototype.investForm = function () {
            if (this.state.cash > 0) {
                var sliders = [
                    maquette_1.h('label', { key: 'label-invest' }, ["Invest $" + commas(this.state.proposed.invest)]),
                    this.slider('invest', 'updateInvest', this.state.cash),
                ];
                if (this.state.debt < 0) {
                    sliders.push(maquette_1.h('label', { key: 'label-pay-debt' }, ["Pay debt $" + commas(this.state.proposed.pay_debt)]));
                    sliders.push(this.slider('pay_debt', 'updatePayDebt', Math.min(-this.state.debt, this.state.cash)));
                }
                return maquette_1.h('form', [maquette_1.h('div.form-group', sliders)]);
            }
            else {
                return '';
            }
        };
        DepressingGame.prototype.inputForm = function () {
            if (!this.state.dead) {
                return maquette_1.h('p', [
                    this.investForm(),
                    this.button(),
                ]);
            }
            else {
                return maquette_1.h('b', ['You died.']);
            }
        };
        DepressingGame.prototype.outputList = function () {
            var displays = [
                makeli('Sex', this.state.sex),
                makeli('Age', this.state.age),
                makeli$('Cash', this.state.cash),
                makeli$('Expenses', this.state.expenses),
                makeli$('Salary', this.state.salary),
            ];
            if (this.state.capital_gains > 0) {
                displays.push(makeli$('Capital gains', this.state.capital_gains));
            }
            if (this.state.invested > 0) {
                displays.push(makeli$('Investments', this.state.invested));
            }
            if (this.state.debt < 0) {
                displays.push(makeli$('Debt', this.state.debt));
            }
            return maquette_1.h('ul', displays);
        };
        DepressingGame.prototype.showLog = function () {
            var logs = this.state.getLogs()
                .map(function (msg) { return maquette_1.h('p', { key: msg.id }, [
                maquette_1.h('b', ["Age " + msg.age + ": "]),
                msg.m
            ]); });
            return maquette_1.h('div', logs);
        };
        DepressingGame.prototype.render = function () {
            return maquette_1.h('div.tile.is-parent', [
                this.outputList(),
                this.inputForm(),
                this.showLog(),
            ]);
        };
        return DepressingGame;
    }());
    // Initialize
    function initialize() {
        var projector = maquette_1.createProjector();
        var rootElem = document.getElementById('game');
        var depressingGame = new DepressingGame();
        if (rootElem !== null) {
            projector.append(rootElem, function () { return depressingGame.render(); });
        }
    }
    exports.initialize = initialize;
});
